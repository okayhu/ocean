- [什么是垃圾](#什么是垃圾)
- [引用的分类](#引用的分类)
- [如何判断一个对象是垃圾（可回收）](#如何判断一个对象是垃圾可回收)
- [Finalize](#finalize)
- [垃圾回收算法](#垃圾回收算法)
  - [复制算法（Copying）](#复制算法copying)
  - [标记-清除算法（Mark-Sweep）](#标记-清除算法mark-sweep)
  - [标记-整理算法（Mark-Compact）](#标记-整理算法mark-compact)
- [垃圾回收器](#垃圾回收器)

## 什么是垃圾



## 引用的分类



## 如何判断一个对象是垃圾（可回收）


## Finalize

Object 类中的 finalize() 方法类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就**有可能**通过在该方法中让对象重新被引用，从而实现自救。

## 垃圾回收算法

### 复制算法（Copying）

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

复制回收算法适合于新生代。因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高。

### 标记-清除算法（Mark-Sweep）

算法分为标记和清除两个阶段。首先扫描出所有对象并标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。 

回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，对比复制回收效率要低，所以标记清除算法适用于老年代。

**主要问题：**

标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

### 标记-整理算法（Mark-Compact）

算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，在标记完成后，不是直接对可回收对象进行清理，而是将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。

标记整理算法虽然没有内存碎片，但是效率偏低。我们看到标记整理算法与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新（**直接指针需要调整**）。

## 垃圾回收器

