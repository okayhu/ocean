## 什么是垃圾



## 引用的分类



## 如何判断一个对象是垃圾（可回收）



## 垃圾回收算法

### 复制算法（Copying）

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

复制回收算法适合于新生代。因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高。

### 标记-清除算法（Mark-Sweep）

算法分为标记和清除两个阶段。首先扫描出所有对象并标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。 

回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，对比复制回收效率要低，所以标记清除算法适用于老年代。

**主要问题：**

标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

### 标记-整理算法（Mark-Compact）

算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，在标记完成后，不是直接对可回收对象进行清理，而是将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。

标记整理算法虽然没有内存碎片，但是效率偏低。我们看到标记整理算法与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新（**直接指针需要调整**）。

## 垃圾回收器

