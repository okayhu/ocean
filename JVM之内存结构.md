## 概述

Java Virtual Machine（JVM）是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件、分析、解释并执行字节码。基本结构如下：

![](https://uposs.justokay.cn/pic/7778a2a9cd8015fa611be7cde1789cb6.png)

Java 虚拟机会在执行 Java 程序的过程中把它所管理的内存划分为若干区域。如图：

![](https://uposs.justokay.cn/pic/93d911980e7b77876e805ddf3632fdf5.png)

JVM 内存结构主要分为三大块：堆、栈和方法区。堆是 JVM 中最大的一块区域，由年轻代和老年代组成，而年轻代内存又分成两部分，Eden 区和 Survivor 区，而 Survivor 区又分为 From 区、To 区，默认情况下年轻代按照 8:1:1 的比例来分配。

通过一张图来了解如何通过参数来控制各区域的内存大小：

![](https://uposs.justokay.cn/pic/78f8eb4e67f1bf3d93cfd257be090683.png)

*-Xms*：设置堆的最小空间大小。

*-Xmx*：设置堆的最大空间大小。

*-XX:NewSize*：设置新生代最小空间大小。

*-XX:MaxNewSize*：设置新生代最大空间大小。

*-XX:PermSize*：设置永久代最小空间大小。

*-XX:MaxPermSize*：设置永久代最大空间大小。

*-Xss*：设置每个线程的堆栈大小。

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。`老年代空间大小 = 堆空间大小 - 年轻代空间大小`

*下面详细介绍下每个区域的作用*

## 堆（Heap）

对于大多数应用来说，堆（Heap）是 Java 虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

堆是垃圾收集器管理的主要区域，如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以堆中还可以细分为：新生代和老年代。当让再细分的话还要，Eden 区、From Survivor 区、To Survivor 区。

根据 Java 虚拟机规范的规定，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。

如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

## 方法区（Method Area）

方法区（Method Area）与堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

对于习惯在 HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为 `永久代`（Permanent Generation），本质上两者并不等价。仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。

Java 虚拟机规范对这个区域的限制非常宽松，除了和堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样永久存在了。** 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 

## 程序计数器（The pc Register）

程序计数器是线程私有的，它可以看作当前线程所执行的字节码的行号指示器。

在字节码解释器工作的时候就是通过改变程序计数器的值来选取和记录下一条要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都要依赖其完成。

- 如果线程正在执行一个 Java 方法，那么程序计数器记录的是正在执行的虚拟机字节码指令的地址。
- 如果正在执行的是一个本地（Native）方法，则计数器值为空（Undefined）。

**程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域**。

## 虚拟机栈（Java Virtual Machine Stacks）

每个线程都有一个私有 Java 虚拟机栈，与该线程同时创建，同时销毁。它保存局部变量和部分结果，并在方法调用和返回中起作用。Java 虚拟机堆栈的内存不必是连续的。

Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：每一个方法在执行的同时都会创建一个栈帧（`Frames`），用于存储 [局部变量表](#局部变量表local-variables-table)、[操作数栈](#操作数栈operand-stacks)、[动态链接](#动态链接-dynamic-linking)、[方法出口](#方法出口-method-invocation-completion) 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程。

- 每个方法对应一个栈帧
- 栈的数据结构是先进后出（`FILO`）的

```java
public static void main(String[] args) {
    Work work = new Work();
    work.a();
}

public void a() {
    b();
}

public void b() {
    // do something
}
```

接下来我们来具体分析一下虚拟机栈帧的结构

### 局部变量表（Local Variables Table）

顾名思义，局部变量表就是用于存放方法参数和方法内定义的局部变量。包括 8 种基本数据类型、对象引用（`reference` 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可以是指向一个代表对象的句柄或者其他与此对象相关的位置）和 `returnAddress` 类型（指向一条字节码指令的地址）。

局部变量表的容量以变量槽（`Variable Slot`）为最小单位，一个 32 bit 的数值会占用一个 Solt，而一个 64 bit 的数值则会占用两个连续的 Solt。

当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递，即从实参到形参的传递。如果执行的是实例方法（非静态），那么局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用（this）

在 Java 程序编译为 Class 文件时，就在方法的 Code 属性中的 `max_locals` 数据项中确定了该方法所需分配的局部变量表的最大容量（Slot数量）。

### 操作数栈（Operand Stacks）

操作数栈是一个后入先出栈（`LIFO`）。当一个方法刚刚开始执行时，其操作数栈是空的。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

每一个操作数栈都会拥有一个明确的栈深度用于存储数值，一个 32 bit 的数值可以用一个单位的栈深度来存储，而 一个 64 bit 的数值则需要 2 个单位的栈深度保存。

操作数栈的最大深度会在编译的时候写入到方法的 Code 属性的 `max_stacks` 数据项中。

### 动态链接 （Dynamic Linking）

每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法间的调用。

### 方法出口 （Method Invocation Completion）

当一个方法开始执行后，只有两种方式退出这个方法。

- 当执行引擎遇到任何一个方法返回的字节码指令时会退出该方法，这种退出称之为：正常调用完成（Normal Method Invocation Completion）。
- 如果在方法执行过程中发生了异常，并且在方法体中没有得到处理，则会导致方法退出。这种退出方式称之为：异常调用完成（Abrupt Method Invocation Completion）。
