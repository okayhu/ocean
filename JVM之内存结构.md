## 概述

Java Virtual Machine（JVM）是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件、分析、解释并执行字节码。基本结构如下：

![](https://uposs.justokay.cn/pic/7778a2a9cd8015fa611be7cde1789cb6.png)

## JVM 内存区域

Java 虚拟机会在执行 Java 程序的过程中把它所管理的内存划分为若干区域。如图：

![](https://uposs.justokay.cn/pic/93d911980e7b77876e805ddf3632fdf5.png)

### 运行时数据区（Run-Time Data Areas）

#### 程序计数器（The pc Register）

程序计数器是线程私有的，它可以看作当前线程所执行的字节码的行号指示器。

在字节码解释器工作的时候就是通过改变程序计数器的值来选取和记录下一条要执行的字节码指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都要依赖其完成。

- 如果线程正在执行一个 Java 方法，那么程序计数器记录的是正在执行的虚拟机字节码指令的地址。
- 如果正在执行的是一个本地（Native）方法，则计数器值为空（Undefined）。

程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 **OutOfMemoryError** 情况的区域。

#### 虚拟机栈（Java Virtual Machine Stacks）

每个线程都有一个私有 Java 虚拟机栈，与该线程同时创建，同时销毁。它保存局部变量和部分结果，并在方法调用和返回中起作用。**Java 虚拟机堆栈的内存不必是连续的**。

Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：每一个方法在执行的同时都会创建一个**栈帧（Frames）**，用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中的入栈到出栈的过程。

- 每个方法对应一个栈帧
- 栈的数据结构是先进后出（`FILO`）的


```java
public static void main(String[] args) {
    Work work = new Work();
    work.a();
}

public void a() {
    b();
}

public void b() {
    // do something
}
```

接下来我们来具体分析一下虚拟机栈帧的结构

**局部变量表（Local Variables Table）**

顾名思义，局部变量表就是用于存放方法参数和方法内定义的局部变量。包括 8 种基本数据类型、对象引用（`reference` 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可以是指向一个代表对象的句柄或者其他与此对象相关的位置）和 `returnAddress` 类型（指向一条字节码指令的地址）。

局部变量表的容量以**变量槽（Variable Slot）**为最小单位，一个 32 bit 的数值会占用一个 Solt，而一个 64 bit 的数值则会占用两个连续的 Solt。

当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递，即从实参到形参的传递。如果执行的是实例方法（非静态），那么局部变量表中第 `0` 位索引的变量槽默认是用于传递方法所属对象实例的引用（`this`）

> 在 Java 程序编译为 Class 文件时，就在方法的 Code 属性中的 max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量（Slot数量）。

**操作数栈（Operand Stacks）**

操作数栈是一个后入先出栈（`LIFO`）。当一个方法刚刚开始执行时，其操作数栈是空的。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

每一个操作数栈都会拥有一个明确的栈深度用于存储数值，一个 32 bit 的数值可以用一个单位的栈深度来存储，而 一个 64 bit 的数值则需要 2 个单位的栈深度保存。

> 操作数栈的最大深度会在编译的时候写入到方法的 Code 属性的 max_stacks 数据项中。

**动态链接 （Dynamic Linking）**

每个栈帧都包含了一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法间的调用。

**方法出口 （Method Invocation Completion）**

当一个方法开始执行后，只有两种方式退出这个方法。

- 当执行引擎遇到任何一个方法返回的字节码指令时会退出该方法，这种退出称之为：正常调用完成（Normal Method Invocation Completion）。
- 如果在方法执行过程中发生了异常，并且在方法体中没有得到处理，则会导致方法退出。这种退出方式称之为：异常调用完成（Abrupt Method Invocation Completion）。






