- [什么是垃圾](#什么是垃圾)
- [引用的分类](#引用的分类)
- [如何判断一个对象是垃圾（可回收）](#如何判断一个对象是垃圾可回收)
  - [引用计数器法](#引用计数器法)
  - [可达性分析算法](#可达性分析算法)
- [Finalize](#finalize)
- [垃圾回收算法](#垃圾回收算法)
  - [复制算法（Copying）](#复制算法copying)
  - [标记-清除算法（Mark-Sweep）](#标记-清除算法mark-sweep)
  - [标记-整理算法（Mark-Compact）](#标记-整理算法mark-compact)
- [垃圾回收器](#垃圾回收器)
  - [新生代垃圾回收器](#新生代垃圾回收器)
  - [老年代垃圾回收器](#老年代垃圾回收器)

## 什么是垃圾

没有任何引用的对象。

## 引用的分类

**强引用**：我们平时 new 了一个对象就是强引用，例如 `Object obj = new Object()`。即使在内存不足的情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种对象。

**软引用**：如果一个对象只具有软引用，则内存空间足够，垃圾回收器不会回收它，如果内存不足，则在发生内存溢出之前被回收。

```java
SoftReference<String> softRef = new SoftReference<String>(str); 
```

**弱引用**：具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器进行垃圾回收时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

```java
WeakReference<String> weakRef = new WeakReference<String>(str);
```

**虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```java
ReferenceQueue queue = new ReferenceQueue();
PhantomReference phantomRef = new PhantomReference(str, queue);
```

## 如何判断一个对象是垃圾（可回收）

### 引用计数器法

为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。

引用计数器无法解决循环应用的问题。

### 可达性分析算法

从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

作为 GC Roots 的对象包括下面几种（重点是前面 4 种）： 

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。 
- 方法区中类静态属性引用的对象、java 类的引用类型静态变量。 
- 方法区中常量引用的对象。比如：字符串常量池里的引用。 
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。 
- JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。
- 所有被同步锁（synchronized 关键字）持有的对象。
- JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。
- JVM 实现中的临时性对象，跨代引用的对象。

以上的回收都是对象，类（Class）的回收条件非常苛刻，必须同时满足以下的条件（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 

*-Xnoclassgc*：禁用类的垃圾回收。

废弃的常量和静态变量的回收其实就和 Class 回收的条件差不多。

## Finalize

Object 类中的 finalize() 方法类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用 finalize()。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就**有可能**通过在该方法中让对象重新被引用，从而实现自救。

## 垃圾回收算法

### 复制算法（Copying）

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

复制回收算法适合于新生代。因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高。

### 标记-清除算法（Mark-Sweep）

算法分为标记和清除两个阶段。首先扫描出所有对象并标记出需要回收的对象，在标记完成后扫描回收所有被标记的对象，所以需要扫描两遍。 

回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，对比复制回收效率要低，所以标记清除算法适用于老年代。

**主要问题：**

标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

### 标记-整理算法（Mark-Compact）

算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，在标记完成后，不是直接对可回收对象进行清理，而是将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。

标记整理算法虽然没有内存碎片，但是效率偏低。我们看到标记整理算法与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新（**直接指针需要调整**）。

## 垃圾回收器

![](https://uposs.justokay.cn/pic/0994ed65d711e1b54b5ebb7ba143daa2.png)

新生代可配置的回收器：Serial、ParNew、Parallel Scavenge

老年代配置的回收器：CMS、Serial Old、Parallel Old

新生代和老年代区域的回收器之间进行连线，说明他们之间可以搭配使用。

### 新生代垃圾回收器

**Serial 垃圾回收器**

Serial 收集器是最基本的、发展历史最悠久的收集器。俗称为：串行回收器，采用复制算法进行垃圾回收。

串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程。对于并行能力较弱的单 CPU 计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。

它存在 Stop The World 问题，及垃圾回收时，要停止程序的运行。设置 *-XX:+UseSerialGC* 参数可以设置新生代使用这个串行回收器。

**ParNew 垃圾回收器**

ParNew 其实就是 Serial 的多线程版本，除了使用多线程之外，其余参数和 Serial 一模一样。俗称：并行垃圾回收器，采用复制算法进行垃圾回收。

ParNew 默认开启的线程数与 CPU 数量相同，在 CPU 核数很多的机器上，可以通过参数 *-XX:ParallelGCThreads* 来设置线程数。

它同样存在 Stop The World 问题，设置 *-XX:+UseParNewGC* 参数可以设置新生代使用这个并行回收器。

**Parallel Scavenge 垃圾回收器**

Parallel Scavenge 使用复制算法回收垃圾，是多线程串行的。Parallel Scavenge 可以提升系统的吞吐量（吞吐量 = 代码运行时间/（代码运行时间+垃圾收集时间））

*-XX:MaxGCPauseMillis*：设置最大垃圾收集停顿时间，可用把虚拟机在 GC 停顿的时间控制在 MaxGCPauseMillis 范围内。如果希望减少 GC 停顿时间可以将 MaxGCPauseMillis 设置的很小，但是会导致 GC 频繁，从而增加了 GC 的总时间，降低了吞吐量。所以需要根据实际情况设置该值。

*-Xx:GCTimeRatio*：设置吞吐量大小，它是一个 0 到 100 之间的整数，默认情况下他的取值是 99，那么系统将花费不超过 1/(1+n)的时间用于垃圾回收，也就是 1/(1+99)=1%的时间。

*-XX:+UseAdaptiveSizePolicy*：打开自适应模式。在这种模式下，新生代的大小、Eden 区、from/to 区的比例，以及晋升老年代的对象年龄参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。

*-XX:+UseParallelGC*：设置新生代使用这个并行回收器。

### 老年代垃圾回收器

**Serial Old 垃圾回收器**

Serial Old 是 Serial 垃圾回收器的老年代垃圾回收器版本，它同样是一个单线程回收器，使用标记整理算法。

在 JDK1.5 及之前的版本中与 Parallel Scavenge 垃圾收集器搭配使用，并且可以作为 CMS 垃圾收集器的后备预案，如果 CMS 出现 `Concurrent Mode Failure` ，则使用 Serial Old 替换 CMS 垃圾收集器。

**Parallel Old 垃圾回收器**

Parallel Old 也是一种多线程的串行回收器，和 Parallel Scavenge 一样，也是一种关注吞吐量的回收器，使用了标记压缩算法进行实现。

*-XX:+UseParallelOldGc*：设置老年代使用该回收器

*-XX:+ParallelGCThreads*：设置垃圾收集时的线程数量。

**CMS、G1 垃圾回收器**

[JVM 之详解 CMS 和 G1 垃圾回收器](JVM 之详解 CMS 和 G1 垃圾回收器.md)